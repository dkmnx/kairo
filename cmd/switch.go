package cmd

import (
	"fmt"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"syscall"

	"github.com/dkmnx/kairo/internal/audit"
	"github.com/dkmnx/kairo/internal/config"
	"github.com/dkmnx/kairo/internal/crypto"
	"github.com/dkmnx/kairo/internal/ui"
	"github.com/dkmnx/kairo/internal/version"
	"github.com/spf13/cobra"
)

// execCommand is the function used to execute external commands.
// It can be replaced in tests to avoid actual process execution.
var execCommand = exec.Command

// exitProcess is the function used to terminate the process.
// It can be replaced in tests to avoid actual exit calls.
var exitProcess = os.Exit

// lookPath is the function used to search for executables in PATH.
// It can be replaced in tests to avoid requiring actual executables.
var lookPath = exec.LookPath

// createTempAuthDir creates a private temporary directory for storing auth files.
// The directory is created with 0700 permissions (owner only) to ensure security.
// Returns the path to the temporary directory.
func createTempAuthDir() (string, error) {
	authDir, err := os.MkdirTemp("", "kairo-auth-")
	if err != nil {
		return "", fmt.Errorf("failed to create temp auth directory: %w", err)
	}

	// Set directory permissions to 0700 (owner read/write/execute only)
	if err := os.Chmod(authDir, 0700); err != nil {
		_ = os.RemoveAll(authDir)
		return "", fmt.Errorf("failed to set auth directory permissions: %w", err)
	}

	return authDir, nil
}

// writeTempTokenFile creates a temporary file with the API key content.
// The file is created with 0600 permissions (owner read/write only) to ensure security.
// Returns the path to the temporary file.
func writeTempTokenFile(authDir, token string) (string, error) {
	f, err := os.CreateTemp(authDir, "token-")
	if err != nil {
		return "", fmt.Errorf("failed to create temp token file: %w", err)
	}

	if _, err := f.WriteString(token); err != nil {
		_ = f.Close()
		return "", fmt.Errorf("failed to write token to temp file: %w", err)
	}

	if err := f.Close(); err != nil {
		return "", fmt.Errorf("failed to close temp token file: %w", err)
	}

	// Set file permissions to 0600 (owner read/write only)
	if err := os.Chmod(f.Name(), 0600); err != nil {
		return "", fmt.Errorf("failed to set temp file permissions: %w", err)
	}

	return f.Name(), nil
}

// escapePowerShellArg escapes a string for use as a PowerShell argument.
// It wraps the argument in single quotes and escapes special characters to prevent
// command injection. Special characters escaped:
// - Single quotes (') -> escaped as ”
// - Backticks (`) -> escaped as “
// - Dollar signs ($) -> escaped as `$ (to prevent variable expansion)
// - Double quotes (") -> escaped as \"
func escapePowerShellArg(arg string) string {
	// First, escape backticks (must be done before other replacements)
	arg = strings.ReplaceAll(arg, "`", "``")
	// Escape dollar signs to prevent variable expansion
	arg = strings.ReplaceAll(arg, "$", "`$")
	// Escape double quotes
	arg = strings.ReplaceAll(arg, "\"", "\\\"")
	// Finally, escape single quotes by doubling them
	arg = strings.ReplaceAll(arg, "'", "''")
	// Wrap in single quotes for safest passing
	return "'" + arg + "'"
}

// generateWrapperScript creates a temporary script that:
// 1. Reads the API key from the token file
// 2. Sets ANTHROPIC_AUTH_TOKEN environment variable
// 3. Cleans up the token file
// 4. Executes the claude command with the provided arguments
// Returns the path to the wrapper script and whether to use shell execution.
func generateWrapperScript(authDir, tokenPath, claudePath string, claudeArgs []string) (string, bool, error) {
	isWindows := runtime.GOOS == "windows"

	f, err := os.CreateTemp(authDir, "wrapper-")
	if err != nil {
		return "", false, fmt.Errorf("failed to create temp wrapper script: %w", err)
	}

	var scriptContent string

	if isWindows {
		// Windows PowerShell script
		scriptContent = "# Generated by kairo - DO NOT EDIT\r\n"
		scriptContent += "# This script will be automatically deleted after execution\r\n"
		// Read token from file and set environment variable
		scriptContent += fmt.Sprintf("$env:ANTHROPIC_AUTH_TOKEN = Get-Content -Path %q -Raw\r\n", tokenPath)
		// Remove the token file after reading
		scriptContent += fmt.Sprintf("Remove-Item -Path %q -Force\r\n", tokenPath)
		// Execute claude with the token as environment variable
		scriptContent += fmt.Sprintf("& %q", claudePath)
		for _, arg := range claudeArgs {
			scriptContent += fmt.Sprintf(" %s", escapePowerShellArg(arg))
		}
		scriptContent += "\r\n"
	} else {
		// Unix shell script
		scriptContent = "#!/bin/sh\n"
		scriptContent += "# Generated by kairo - DO NOT EDIT\n"
		scriptContent += "# This script will be automatically deleted after execution\n"
		// Read token from file and export as environment variable
		scriptContent += fmt.Sprintf("export ANTHROPIC_AUTH_TOKEN=$(cat %q)\n", tokenPath)
		// Remove the token file after reading
		scriptContent += fmt.Sprintf("rm -f %q\n", tokenPath)
		// Execute claude with the token as environment variable
		scriptContent += "exec " + fmt.Sprintf("%q", claudePath)
		for _, arg := range claudeArgs {
			scriptContent += " " + fmt.Sprintf("%q", arg)
		}
		scriptContent += "\n"
	}

	if _, err := f.WriteString(scriptContent); err != nil {
		_ = f.Close()
		_ = os.Remove(f.Name())
		return "", false, fmt.Errorf("failed to write wrapper script: %w", err)
	}

	if err := f.Close(); err != nil {
		_ = os.Remove(f.Name())
		return "", false, fmt.Errorf("failed to close wrapper script: %w", err)
	}

	// Make the script executable (Unix) or rename to .ps1 (Windows PowerShell)
	if isWindows {
		ps1Path := f.Name() + ".ps1"
		if err := os.Rename(f.Name(), ps1Path); err != nil {
			_ = os.Remove(f.Name())
			return "", false, fmt.Errorf("failed to rename wrapper script: %w", err)
		}
		return ps1Path, true, nil
	}

	if err := os.Chmod(f.Name(), 0700); err != nil {
		_ = os.Remove(f.Name())
		return "", false, fmt.Errorf("failed to make wrapper script executable: %w", err)
	}

	return f.Name(), false, nil
}

var switchCmd = &cobra.Command{
	Use:   "switch <provider> [args]",
	Short: "Switch to a provider and execute Claude",
	Long:  "Switch to the specified provider and execute Claude Code with optional arguments",
	Args:  cobra.MinimumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		providerName := args[0]

		dir := getConfigDir()
		if dir == "" {
			cmd.Println("Error: config directory not found")
			return
		}

		cfg, err := config.LoadConfig(dir)
		if err != nil {
			cmd.Printf("Error loading config: %v\n", err)
			return
		}

		provider, ok := cfg.Providers[providerName]
		if !ok {
			cmd.Printf("Error: provider '%s' not configured\n", providerName)
			return
		}

		logAuditEvent(dir, func(logger *audit.Logger) error {
			return logger.LogSwitch(providerName)
		})

		providerEnv := os.Environ()
		// Environment variable name constants for model configuration
		const (
			envBaseURL     = "ANTHROPIC_BASE_URL"
			envModel       = "ANTHROPIC_MODEL"
			envHaikuModel  = "ANTHROPIC_DEFAULT_HAIKU_MODEL"
			envSonnetModel = "ANTHROPIC_DEFAULT_SONNET_MODEL"
			envOpusModel   = "ANTHROPIC_DEFAULT_OPUS_MODEL"
			envSmallFast   = "ANTHROPIC_SMALL_FAST_MODEL"
		)

		providerEnv = append(providerEnv, fmt.Sprintf("%s=%s", envBaseURL, provider.BaseURL))
		providerEnv = append(providerEnv, fmt.Sprintf("%s=%s", envModel, provider.Model))

		providerEnv = append(providerEnv, fmt.Sprintf("%s=%s", envHaikuModel, provider.Model))
		providerEnv = append(providerEnv, fmt.Sprintf("%s=%s", envSonnetModel, provider.Model))
		providerEnv = append(providerEnv, fmt.Sprintf("%s=%s", envOpusModel, provider.Model))
		providerEnv = append(providerEnv, fmt.Sprintf("%s=%s", envSmallFast, provider.Model))

		providerEnv = append(providerEnv, provider.EnvVars...)

		secretsPath := filepath.Join(dir, "secrets.age")
		keyPath := filepath.Join(dir, "age.key")
		secretsContent, err := crypto.DecryptSecrets(secretsPath, keyPath)
		if err != nil {
			if getVerbose() {
				ui.PrintInfo(fmt.Sprintf("Warning: Could not decrypt secrets: %v", err))
			}
		} else {
			secrets := config.ParseSecrets(secretsContent)
			for key, value := range secrets {
				providerEnv = append(providerEnv, fmt.Sprintf("%s=%s", key, value))
			}
			apiKeyKey := fmt.Sprintf("%s_API_KEY", strings.ToUpper(providerName))
			if apiKey, ok := secrets[apiKeyKey]; ok {
				// SECURE: Create private auth directory and use wrapper script
				// This prevents API key from being visible in /proc/<pid>/environ
				// and ensures files are only accessible to the current user
				authDir, err := createTempAuthDir()
				if err != nil {
					cmd.Printf("Error creating auth directory: %v\n", err)
					return
				}

				var cleanupOnce sync.Once
				cleanup := func() {
					cleanupOnce.Do(func() {
						_ = os.RemoveAll(authDir)
					})
				}
				defer cleanup()

				tokenPath, err := writeTempTokenFile(authDir, apiKey)
				if err != nil {
					cmd.Printf("Error creating secure token file: %v\n", err)
					return
				}

				claudeArgs := args[1:]
				claudePath, err := lookPath("claude")
				if err != nil {
					cmd.Println("Error: 'claude' command not found in PATH")
					return
				}

				wrapperScript, useCmdExe, err := generateWrapperScript(authDir, tokenPath, claudePath, claudeArgs)
				if err != nil {
					cmd.Printf("Error generating wrapper script: %v\n", err)
					return
				}

				ui.PrintBanner(version.Version, provider.Name)

				// Set up signal handling for cleanup on SIGINT/SIGTERM
				sigChan := make(chan os.Signal, 1)
				defer func() {
					signal.Stop(sigChan)
					close(sigChan)
				}()
				signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

				go func() {
					sig := <-sigChan
					cleanup()
					// Exit with signal code (cross-platform)
					code := 128
					if s, ok := sig.(syscall.Signal); ok {
						code += int(s)
					}
					exitProcess(code)
				}()

				// Execute the wrapper script instead of claude directly
				// The wrapper script will:
				// 1. Read the API key from the temp file
				// 2. Set ANTHROPIC_AUTH_TOKEN environment variable
				// 3. Delete the temp file
				// 4. Execute claude with the proper arguments
				var execCmd *exec.Cmd
				if useCmdExe {
					// On Windows, use cmd /c to execute the batch file
					execCmd = execCommand("powershell", "-NoProfile", "-ExecutionPolicy", "Bypass", "-File", wrapperScript)
				} else {
					execCmd = execCommand(wrapperScript)
				}
				execCmd.Env = providerEnv
				execCmd.Stdin = os.Stdin
				execCmd.Stdout = os.Stdout
				execCmd.Stderr = os.Stderr

				if err := execCmd.Run(); err != nil {
					cmd.Printf("Error running Claude: %v\n", err)
					exitProcess(1)
				}
				return
			}
		}

		// No API key found, run claude directly without auth token
		claudeArgs := args[1:]

		claudePath, err := lookPath("claude")
		if err != nil {
			cmd.Println("Error: 'claude' command not found in PATH")
			return
		}

		ui.PrintBanner(version.Version, provider.Name)

		execCmd := execCommand(claudePath, claudeArgs...)
		execCmd.Env = providerEnv
		execCmd.Stdin = os.Stdin
		execCmd.Stdout = os.Stdout
		execCmd.Stderr = os.Stderr

		if err := execCmd.Run(); err != nil {
			cmd.Printf("Error running Claude: %v\n", err)
			exitProcess(1)
		}
	},
}

func init() {
	rootCmd.AddCommand(switchCmd)
}
