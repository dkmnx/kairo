package wrapper

import (
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strings"
)

// CreateTempAuthDir creates a private temporary directory for storing auth files.
// The directory is created with 0700 permissions (owner only) to ensure security.
// Returns the path to the temporary directory.
func CreateTempAuthDir() (string, error) {
	authDir, err := os.MkdirTemp("", "kairo-auth-")
	if err != nil {
		return "", fmt.Errorf("failed to create temp auth directory: %w", err)
	}

	if err := os.Chmod(authDir, 0700); err != nil {
		_ = os.RemoveAll(authDir)
		return "", fmt.Errorf("failed to set auth directory permissions: %w", err)
	}

	return authDir, nil
}

// WriteTempTokenFile creates a temporary file with the API key content.
// The file is created with 0600 permissions (owner read/write only) to ensure security.
// Returns the path to the temporary file.
func WriteTempTokenFile(authDir, token string) (string, error) {
	if token == "" {
		return "", fmt.Errorf("token cannot be empty")
	}

	f, err := os.CreateTemp(authDir, "token-")
	if err != nil {
		return "", fmt.Errorf("failed to create temp token file: %w", err)
	}

	if _, err := f.WriteString(token); err != nil {
		_ = f.Close()
		return "", fmt.Errorf("failed to write token to temp file: %w", err)
	}

	if err := f.Close(); err != nil {
		return "", fmt.Errorf("failed to close temp token file: %w", err)
	}

	if err := os.Chmod(f.Name(), 0600); err != nil {
		return "", fmt.Errorf("failed to set temp file permissions: %w", err)
	}

	return f.Name(), nil
}

// EscapePowerShellArg escapes a string for use as a PowerShell argument.
// It wraps the argument in single quotes and escapes special characters to prevent
// command injection.
func EscapePowerShellArg(arg string) string {
	arg = strings.ReplaceAll(arg, "`", "``")
	arg = strings.ReplaceAll(arg, "$", "`$")
	arg = strings.ReplaceAll(arg, "\"", "\\\"")
	arg = strings.ReplaceAll(arg, "'", "''")
	return "'" + arg + "'"
}

// GenerateWrapperScript creates a temporary script that reads the API key from the
// token file, sets ANTHROPIC_AUTH_TOKEN environment variable, cleans up the token
// file, and executes the claude command with the provided arguments.
// Returns the path to the wrapper script and whether to use shell execution.
func GenerateWrapperScript(authDir, tokenPath, claudePath string, claudeArgs []string) (string, bool, error) {
	if tokenPath == "" {
		return "", false, fmt.Errorf("token path cannot be empty")
	}
	if claudePath == "" {
		return "", false, fmt.Errorf("claude path cannot be empty")
	}

	isWindows := runtime.GOOS == "windows"

	f, err := os.CreateTemp(authDir, "wrapper-")
	if err != nil {
		return "", false, fmt.Errorf("failed to create temp wrapper script: %w", err)
	}

	var scriptContent string

	if isWindows {
		scriptContent = "# Generated by kairo - DO NOT EDIT\r\n"
		scriptContent += "# This script will be automatically deleted after execution\r\n"
		scriptContent += fmt.Sprintf("$env:ANTHROPIC_AUTH_TOKEN = Get-Content -Path %q -Raw\r\n", tokenPath)
		scriptContent += fmt.Sprintf("Remove-Item -Path %q -Force\r\n", tokenPath)
		scriptContent += fmt.Sprintf("& %q", claudePath)
		for _, arg := range claudeArgs {
			scriptContent += fmt.Sprintf(" %s", EscapePowerShellArg(arg))
		}
		scriptContent += "\r\n"
	} else {
		scriptContent = "#!/bin/sh\n"
		scriptContent += "# Generated by kairo - DO NOT EDIT\n"
		scriptContent += "# This script will be automatically deleted after execution\n"
		scriptContent += fmt.Sprintf("export ANTHROPIC_AUTH_TOKEN=$(cat %q)\n", tokenPath)
		scriptContent += fmt.Sprintf("rm -f %q\n", tokenPath)
		scriptContent += "exec " + fmt.Sprintf("%q", claudePath)
		for _, arg := range claudeArgs {
			scriptContent += " " + fmt.Sprintf("%q", arg)
		}
		scriptContent += "\n"
	}

	if _, err := f.WriteString(scriptContent); err != nil {
		_ = f.Close()
		_ = os.Remove(f.Name())
		return "", false, fmt.Errorf("failed to write wrapper script: %w", err)
	}

	if err := f.Close(); err != nil {
		_ = os.Remove(f.Name())
		return "", false, fmt.Errorf("failed to close wrapper script: %w", err)
	}

	if isWindows {
		ps1Path := f.Name() + ".ps1"
		if err := os.Rename(f.Name(), ps1Path); err != nil {
			_ = os.Remove(f.Name())
			return "", false, fmt.Errorf("failed to rename wrapper script: %w", err)
		}
		return ps1Path, true, nil
	}

	if err := os.Chmod(f.Name(), 0700); err != nil {
		_ = os.Remove(f.Name())
		return "", false, fmt.Errorf("failed to make wrapper script executable: %w", err)
	}

	return f.Name(), false, nil
}

// ExecCommand wraps exec.Command for testability.
func ExecCommand(name string, arg ...string) *exec.Cmd {
	return exec.Command(name, arg...)
}
